<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NOS-GOLD Music Generator</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui, sans-serif; padding: 24px; background:#0b0d10; color:#e8e8e8; }
    h1 { margin: 0 0 10px; font-size: 28px; letter-spacing: 0.5px; }
    .top { display:flex; gap:18px; flex-wrap:wrap; align-items:flex-start; }
    .panel { background:#0f141c; border:1px solid #1b2330; border-radius:16px; padding:14px 16px; box-shadow: 0 8px 22px rgba(0,0,0,.25); }
    button { font-size: 16px; padding: 10px 14px; border-radius: 12px; border: 0; cursor: pointer; background:#e8e8e8; color:#0b0d10; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .row { margin-top: 10px; display:grid; grid-template-columns: 110px 260px 64px; gap:10px; align-items:center;}
    label { opacity:.9; }
    input[type="range"]{ width:260px; }
    .hint { opacity:.75; margin-top: 10px; line-height:1.4; font-size: 13px;}
    canvas { width: 420px; height: 420px; border-radius: 16px; border:1px solid #1b2330; background:#000; }
    .btns { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .small { font-size: 12px; opacity:.8; }
  </style>
</head>
<body>
  <h1>NOS-GOLD Music Generator</h1>

  <div class="top">
    <div class="panel">
      <div class="btns">
        <button id="start">Start</button>
        <button id="stop" disabled>Stop</button>
        <span class="small">Sliders update live while playing.</span>
      </div>

      <div class="row">
        <label for="tempo">Tempo</label>
        <input id="tempo" type="range" min="60" max="98" value="78"/>
        <div id="tempoVal">78</div>
      </div>

      <div class="row">
        <label for="lofi">Lo-fi</label>
        <input id="lofi" type="range" min="0" max="1" step="0.01" value="0.65"/>
        <div id="lofiVal">0.65</div>
      </div>

      <div class="row">
        <label for="dens">Density</label>
        <input id="dens" type="range" min="0" max="1" step="0.01" value="0.55"/>
        <div id="densVal">0.55</div>
      </div>

      <div class="row">
        <label for="bassVar">Bass Rand</label>
        <input id="bassVar" type="range" min="0" max="1" step="0.01" value="0.35"/>
        <div id="bassVarVal">0.35</div>
      </div>

      <div class="row">
        <label for="trebleVar">Treble Rand</label>
        <input id="trebleVar" type="range" min="0" max="1" step="0.01" value="0.45"/>
        <div id="trebleVarVal">0.45</div>
      </div>

      <!-- three extra effects sliders -->
      <div class="row">
        <label for="fxDelay">Delay</label>
        <input id="fxDelay" type="range" min="0" max="1" step="0.01" value="0.35"/>
        <div id="fxDelayVal">0.35</div>
      </div>

      <div class="row">
        <label for="fxReverb">Reverb</label>
        <input id="fxReverb" type="range" min="0" max="1" step="0.01" value="0.25"/>
        <div id="fxReverbVal">0.25</div>
      </div>

      <div class="row">
        <label for="fxChorus">Chorus</label>
        <input id="fxChorus" type="range" min="0" max="1" step="0.01" value="0.30"/>
        <div id="fxChorusVal">0.30</div>
      </div>

      <div class="hint">
        WebAudio needs a user gesture to start. Leave it running; harmony + timbre drift slowly.
        The fractal’s parameters are driven by the same evolving music variables.
      </div>
    </div>

    <div class="panel">
      <canvas id="fractal" width="360" height="360"></canvas>
      <div class="hint">Julia fractal (live). It “breathes” with lo-fi, density, wow/flutter, bass/treble randomness, and FX.</div>
    </div>
  </div>

<script>
(() => {
  // ---------- utilities ----------
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const rnd   = (a=1,b=0)=>Math.random()*(a-b)+b;
  const choose= (arr)=>arr[(Math.random()*arr.length)|0];
  const mtof  = (m)=>440*Math.pow(2,(m-69)/12);

  // smooth random walk
  function smoothWander(state, step=0.01, pull=0.002) {
    state.dv += rnd(step, -step) - state.v*pull;
    state.dv *= 0.995;
    state.v += state.dv;
    return state.v;
  }

  // ---------- audio graph ----------
  let ac, master, isRunning=false, timer=null;

  // tweakable nodes
  let masterLP, masterHP, masterComp, masterSat;
  let noiseGain;
  let lofiMix;
  let tapeDelay, tapeFB, delaySend;
  let tapeWowLFO, tapeWowGain, tapeFlutterLFO, tapeFlutterGain;
  let bitCrusher;

  // reverb
  let convolver, reverbSend, reverbGain;

  // chorus
  let chorusDelay, chorusLFO, chorusDepth, chorusMix;

  // buses
  let drumBus, musicBus;
  let kickGain, snareGain, hatGain;
  let chordBus, bassBus, leadBus;

  // ---------- musical state ----------
  const state = {
    bpm: 78,
    lofi: 0.65,
    density: 0.55,
    bassVar: 0.35,
    trebleVar: 0.45,
    fxDelay: 0.35,
    fxReverb: 0.25,
    fxChorus: 0.30,

    keyRoot: 57,
    mode: "minor",
    bar: 0,
    step: 0,
    nextTime: 0,

    drift:   { v: 0, dv: 0 },
    bright:  { v: 0, dv: 0 },
    wow:     { v: 0, dv: 0 },
    flutter: { v: 0, dv: 0 },
    swing:   { v: 0, dv: 0 },

    prog:    [0, 5, 3, 6],
    progAlt: [0, 3, 4, 5],
    useAlt: false,
  };

  function secondsPerBeat(){ return 60/state.bpm; }

  function scaleForMode(rootMidi, mode) {
    const MAJ = [0,2,4,5,7,9,11];
    const MIN = [0,2,3,5,7,8,10];
    return (mode==="major"?MAJ:MIN).map(i => rootMidi+i);
  }

  function chordFromDegree(scale, degreeIndex, oct=0) {
    const deg = degreeIndex % 7;
    const root = scale[deg] + oct*12;
    const third = scale[(deg+2)%7] + (deg+2>=7?12:0) + oct*12;
    const fifth = scale[(deg+4)%7] + (deg+4>=7?12:0) + oct*12;
    const seventh = scale[(deg+6)%7] + (deg+6>=7?12:0) + oct*12;
    return [root, third, fifth, seventh];
  }

  function quantToScale(m, scale) {
    const pc = ((m%12)+12)%12;
    const pcs = scale.map(x=>((x%12)+12)%12);
    let best = pcs[0], bestD = 99;
    for (const p of pcs) {
      const d = Math.min((pc-p+12)%12, (p-pc+12)%12);
      if (d < bestD) { bestD = d; best = p; }
    }
    return m + (((best - pc) + 12) % 12);
  }

  function makeSaturationCurve(amount=0.6) {
    const n = 44100;
    const curve = new Float32Array(n);
    const k = clamp(amount,0,1)*12 + 1;
    for (let i=0;i<n;i++){
      const x = (i*2/n)-1;
      curve[i] = Math.tanh(k*x)/Math.tanh(k);
    }
    return curve;
  }

  function makeNoiseSrc() {
    const bufferSize = 2 * ac.sampleRate;
    const buffer = ac.createBuffer(1, bufferSize, ac.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * 0.35;
    const src = ac.createBufferSource();
    src.buffer = buffer;
    src.loop = true;
    src.start();
    return src;
  }

  function makeBitCrusher() {
    const node = ac.createScriptProcessor(1024, 1, 1);
    let phase = 0, last = 0;
    let reduction = 0.6, downsample = 6;
    node.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0);
      const output = e.outputBuffer.getChannelData(0);
      for (let i=0;i<input.length;i++){
        phase++;
        if (phase >= downsample) {
          phase = 0;
          const steps = 2 + Math.floor(62*(1-reduction));
          last = Math.round(input[i]*steps)/steps;
        }
        output[i] = last;
      }
    };
    return {
      input: node, output: node,
      set(amount, ds) { reduction = clamp(amount,0,1); downsample = clamp(ds|0,1,32); }
    };
  }

  function makeImpulseResponse(seconds=1.8, decay=2.2) {
    const rate = ac.sampleRate;
    const len = Math.floor(rate * seconds);
    const ir = ac.createBuffer(2, len, rate);
    for (let ch=0; ch<2; ch++){
      const d = ir.getChannelData(ch);
      for (let i=0;i<len;i++){
        const t = i/len;
        // slightly colored + decaying noise
        d[i] = (Math.random()*2-1) * Math.pow(1-t, decay);
      }
    }
    return ir;
  }

  function softLP(freq, q=0.4) {
    const f = ac.createBiquadFilter();
    f.type="lowpass"; f.frequency.value=freq; f.Q.value=q;
    return f;
  }

  // ---------- instruments ----------
  let clickBuf=null, snareBuf=null, hatBuf=null;

  function makeClickBuffer() {
    if (clickBuf) return clickBuf;
    const len = 128;
    clickBuf = ac.createBuffer(1, len, ac.sampleRate);
    const d = clickBuf.getChannelData(0);
    for (let i=0;i<len;i++) d[i] = (Math.random()*2-1) * Math.exp(-i/18);
    return clickBuf;
  }

  function makeSnareNoise() {
    if (snareBuf) return snareBuf;
    const len = ac.sampleRate * 0.25;
    snareBuf = ac.createBuffer(1, len|0, ac.sampleRate);
    const d = snareBuf.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * Math.exp(-i/2000);
    return snareBuf;
  }

  function makeHatNoise() {
    if (hatBuf) return hatBuf;
    const len = ac.sampleRate * 0.12;
    hatBuf = ac.createBuffer(1, len|0, ac.sampleRate);
    const d = hatBuf.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * Math.exp(-i/900);
    return hatBuf;
  }

  function playKick(t) {
    const o = ac.createOscillator();
    o.type = "sine";
    const g = ac.createGain();

    o.frequency.setValueAtTime(140, t);
    o.frequency.exponentialRampToValueAtTime(52, t + 0.09);

    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(1.0, t + 0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.22);

    const click = ac.createBufferSource();
    click.buffer = makeClickBuffer();
    const cg = ac.createGain();
    cg.gain.setValueAtTime(0.2, t);
    cg.gain.exponentialRampToValueAtTime(0.0001, t+0.02);

    o.connect(g); g.connect(kickGain);
    click.connect(cg); cg.connect(kickGain);

    o.start(t); o.stop(t+0.35);
    click.start(t); click.stop(t+0.03);
  }

  function playSnare(t, tone=2100) {
    const n = ac.createBufferSource();
    n.buffer = makeSnareNoise();
    const nf = ac.createBiquadFilter();
    nf.type = "bandpass"; nf.frequency.value = tone; nf.Q.value = 0.6;

    const ng = ac.createGain();
    ng.gain.setValueAtTime(0.0001, t);
    ng.gain.exponentialRampToValueAtTime(0.65, t+0.004);
    ng.gain.exponentialRampToValueAtTime(0.0001, t+0.18);

    n.connect(nf); nf.connect(ng); ng.connect(snareGain);

    const o = ac.createOscillator();
    o.type = "triangle"; o.frequency.setValueAtTime(180, t);
    const og = ac.createGain();
    og.gain.setValueAtTime(0.0001, t);
    og.gain.exponentialRampToValueAtTime(0.35, t+0.002);
    og.gain.exponentialRampToValueAtTime(0.0001, t+0.08);
    o.connect(og); og.connect(snareGain);

    n.start(t); n.stop(t+0.22);
    o.start(t); o.stop(t+0.12);
  }

  function playHat(t, open=0.06) {
    const n = ac.createBufferSource();
    n.buffer = makeHatNoise();
    const hp = ac.createBiquadFilter();
    hp.type="highpass"; hp.frequency.value=6500; hp.Q.value=0.3;

    const g = ac.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.25, t+0.001);
    g.gain.exponentialRampToValueAtTime(0.0001, t+open);

    n.connect(hp); hp.connect(g); g.connect(hatGain);
    n.start(t); n.stop(t+open+0.02);
  }

  function envGain(atk, dec, sus, rel, t0, t1) {
    const g = ac.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(1.0, t0 + atk);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0001, sus), t0 + atk + dec);
    g.gain.setValueAtTime(Math.max(0.0001, sus), t1);
    g.gain.exponentialRampToValueAtTime(0.0001, t1 + rel);
    return g;
  }

  function playChord(t0, dur, chordMidi, brightness=0.4) {
    const out = ac.createGain();
    out.gain.value = 1.0;

    const lp = softLP(lerp(900, 4200, brightness), 0.6);
    out.connect(lp);

    // optional chorus send (global chorus already, but extra depth here makes it lush)
    lp.connect(chordBus);

    chordMidi.forEach((m, i) => {
      const o = ac.createOscillator();
      o.type = "triangle";
      o.detune.value = (i-1.5)*rnd(4,2) + rnd(1,-1);
      o.frequency.setValueAtTime(mtof(m), t0);

      const g = envGain(0.12, 0.5, 0.22, 0.35, t0, t0+dur);
      o.connect(g); g.connect(out);

      o.start(t0);
      o.stop(t0 + dur + 1.0);
    });
  }

  function playBass(t0, dur, midi, lofi=0.6, bassVar=0.3) {
    const o = ac.createOscillator();
    o.type = "sawtooth";
    o.frequency.setValueAtTime(mtof(midi), t0);

    const g = envGain(0.01, 0.08, 0.22, 0.12, t0, t0+dur);

    // bass randomness changes cutoff + subtle detune + drive
    const cutoff = lerp(140, 620, 1-lofi) * lerp(0.85, 1.30, bassVar * rnd(1,0));
    const lp = softLP(cutoff, 0.9);

    const ws = ac.createWaveShaper();
    ws.curve = makeSaturationCurve(lerp(0.30, 0.85, lofi) * lerp(0.9, 1.25, bassVar));
    ws.oversample = "2x";

    o.detune.value = rnd(8,-8) * bassVar;

    o.connect(g); g.connect(lp); lp.connect(ws); ws.connect(bassBus);

    o.start(t0);
    o.stop(t0 + dur + 0.3);
  }

  function playLead(t0, dur, midi, bright=0.5, trebleVar=0.4) {
    const o = ac.createOscillator();
    o.type = "sine";
    o.frequency.setValueAtTime(mtof(midi), t0);

    const g = envGain(0.005, 0.09, 0.08, 0.12, t0, t0+dur);

    const bp = ac.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = lerp(800, 3200, bright) * lerp(0.9, 1.25, trebleVar*rnd(1,0));
    bp.Q.value = lerp(1.1, 2.4, trebleVar);

    const l = ac.createOscillator();
    l.type = "sine";
    l.frequency.value = 5.2 + rnd(1.2,-1.2);
    const lg = ac.createGain();
    lg.gain.value = lerp(6, 22, trebleVar); // cents
    l.connect(lg); lg.connect(o.detune);

    o.connect(g); g.connect(bp); bp.connect(leadBus);

    l.start(t0); l.stop(t0+dur+0.4);
    o.start(t0); o.stop(t0+dur+0.4);
  }

  // ---------- build graph ----------
  function makeAC() {
    ac = new (window.AudioContext || window.webkitAudioContext)();

    master = ac.createGain();
    master.gain.value = 0.9;

    masterHP = ac.createBiquadFilter();
    masterHP.type="highpass";
    masterHP.frequency.value = 30;

    masterLP = ac.createBiquadFilter();
    masterLP.type="lowpass";
    masterLP.frequency.value = 14000;
    masterLP.Q.value = 0.5;

    masterSat = ac.createWaveShaper();
    masterSat.curve = makeSaturationCurve(0.7);
    masterSat.oversample = "2x";

    masterComp = ac.createDynamicsCompressor();
    masterComp.threshold.value = -18;
    masterComp.knee.value = 24;
    masterComp.ratio.value = 3.2;
    masterComp.attack.value = 0.01;
    masterComp.release.value = 0.25;

    // Lo-fi split: dry + crushed
    lofiMix = { dry: ac.createGain(), wet: ac.createGain(), sum: ac.createGain() };
    lofiMix.dry.gain.value = 0.55;
    lofiMix.wet.gain.value = 0.45;

    bitCrusher = makeBitCrusher();

    // Tape delay + feedback
    tapeDelay = ac.createDelay(1.0);
    tapeDelay.delayTime.value = 0.13;
    tapeFB = ac.createGain();
    tapeFB.gain.value = 0.18;

    delaySend = ac.createGain();
    delaySend.gain.value = 0.18;

    tapeWowLFO = ac.createOscillator();
    tapeWowLFO.type = "sine";
    tapeWowLFO.frequency.value = 0.22;
    tapeWowGain = ac.createGain();
    tapeWowGain.gain.value = 0.0025;

    tapeFlutterLFO = ac.createOscillator();
    tapeFlutterLFO.type = "sine";
    tapeFlutterLFO.frequency.value = 5.5;
    tapeFlutterGain = ac.createGain();
    tapeFlutterGain.gain.value = 0.00035;

    tapeWowLFO.connect(tapeWowGain);
    tapeFlutterLFO.connect(tapeFlutterGain);
    tapeWowGain.connect(tapeDelay.delayTime);
    tapeFlutterGain.connect(tapeDelay.delayTime);
    tapeWowLFO.start();
    tapeFlutterLFO.start();

    // Reverb
    convolver = ac.createConvolver();
    convolver.buffer = makeImpulseResponse(1.8, 2.2);
    reverbSend = ac.createGain();
    reverbSend.gain.value = 0.18;
    reverbGain = ac.createGain();
    reverbGain.gain.value = 0.25;

    // Chorus (master-ish) using modulated delay
    chorusDelay = ac.createDelay(0.05);
    chorusDelay.delayTime.value = 0.018;
    chorusLFO = ac.createOscillator();
    chorusLFO.type = "sine";
    chorusLFO.frequency.value = 0.19;
    chorusDepth = ac.createGain();
    chorusDepth.gain.value = 0.004;
    chorusMix = ac.createGain();
    chorusMix.gain.value = 0.25;

    chorusLFO.connect(chorusDepth);
    chorusDepth.connect(chorusDelay.delayTime);
    chorusLFO.start();

    // Noise
    noiseGain = ac.createGain();
    noiseGain.gain.value = 0.015;

    const noise = makeNoiseSrc();
    const noiseLP = ac.createBiquadFilter();
    noiseLP.type="lowpass"; noiseLP.frequency.value = 4500; noiseLP.Q.value = 0.2;
    const noiseHP = ac.createBiquadFilter();
    noiseHP.type="highpass"; noiseHP.frequency.value = 200; noiseHP.Q.value = 0.2;
    noise.connect(noiseHP); noiseHP.connect(noiseLP); noiseLP.connect(noiseGain);

    // buses
    drumBus = ac.createGain(); drumBus.gain.value = 0.9;
    musicBus = ac.createGain(); musicBus.gain.value = 0.9;

    chordBus = ac.createGain(); chordBus.gain.value = 0.6;
    bassBus  = ac.createGain(); bassBus.gain.value  = 0.55;
    leadBus  = ac.createGain(); leadBus.gain.value  = 0.25;

    chordBus.connect(musicBus);
    bassBus.connect(musicBus);
    leadBus.connect(musicBus);

    // route to dry
    drumBus.connect(lofiMix.dry);
    musicBus.connect(lofiMix.dry);

    // route to crushed
    drumBus.connect(bitCrusher.input);
    musicBus.connect(bitCrusher.input);
    bitCrusher.output.connect(lofiMix.wet);

    // sum
    lofiMix.dry.connect(lofiMix.sum);
    lofiMix.wet.connect(lofiMix.sum);

    // delay send
    lofiMix.sum.connect(delaySend);
    delaySend.connect(tapeDelay);
    tapeDelay.connect(tapeFB);
    tapeFB.connect(tapeDelay);

    // reverb send
    lofiMix.sum.connect(reverbSend);
    reverbSend.connect(convolver);
    convolver.connect(reverbGain);

    // chorus: feed sum through mod delay and mix back
    lofiMix.sum.connect(chorusDelay);
    chorusDelay.connect(chorusMix);

    // master input
    const preMaster = ac.createGain();
    preMaster.gain.value = 1.0;

    lofiMix.sum.connect(preMaster);
    tapeDelay.connect(preMaster);
    reverbGain.connect(preMaster);
    chorusMix.connect(preMaster);
    noiseGain.connect(preMaster);

    // master chain
    preMaster.connect(masterHP);
    masterHP.connect(masterLP);
    masterLP.connect(masterSat);
    masterSat.connect(masterComp);
    masterComp.connect(master);
    master.connect(ac.destination);

    // drum gains
    kickGain = ac.createGain(); kickGain.gain.value = 0.95;
    snareGain= ac.createGain(); snareGain.gain.value= 0.55;
    hatGain  = ac.createGain(); hatGain.gain.value  = 0.25;

    kickGain.connect(drumBus);
    snareGain.connect(drumBus);
    hatGain.connect(drumBus);
  }

  // ---------- scheduler ----------
  const STEPS_PER_BAR = 16;

  function stepDur(){ return secondsPerBeat()/2; } // 8th grid, with swing offset

  function scheduleAhead() {
    if (!isRunning) return;
    const now = ac.currentTime;
    const lookahead = 0.25;
    while (state.nextTime < now + lookahead) {
      scheduleStep(state.nextTime, state.step, state.bar);
      advanceStep();
    }
  }

  function advanceStep() {
    state.step++;
    const sd = stepDur();
    const swingAmt = clamp(0.02 + 0.05*(state.swing.v*0.5+0.5), 0.0, 0.08);
    const isOff = (state.step % 2) === 1;
    state.nextTime += sd + (isOff ? swingAmt : 0);

    if (state.step >= STEPS_PER_BAR) {
      state.step = 0;
      state.bar++;
      onNewBar();
    }
  }

  function onNewBar() {
    if (state.bar % 8 === 0 && Math.random() < 0.35) state.useAlt = !state.useAlt;

    if (state.bar % 16 === 0 && Math.random() < 0.28) {
      const shift = choose([ -2, -5, 2, 5 ]);
      state.keyRoot = clamp(state.keyRoot + shift, 45, 69);
      if (Math.random() < 0.25) state.mode = (state.mode==="minor" ? "major" : "minor");
    }
  }

  function scheduleStep(t, step, bar) {
    // slow drift
    const drift   = smoothWander(state.drift,   0.004, 0.0015);
    const bright  = smoothWander(state.bright,  0.006, 0.002);
    const wow     = smoothWander(state.wow,     0.004, 0.0015);
    const flutter = smoothWander(state.flutter, 0.004, 0.0015);
    smoothWander(state.swing, 0.002, 0.0012);

    // LIVE params (sliders update state continuously)
    const lofi     = state.lofi;
    const dens     = state.density;
    const bassVar  = state.bassVar;
    const trebVar  = state.trebleVar;
    const fxDelay  = state.fxDelay;
    const fxReverb = state.fxReverb;
    const fxChorus = state.fxChorus;

    // master tone breathes + treble randomness influences cutoff range
    const trebleBreathe = clamp(0.35 + bright*0.35 + (1-lofi)*0.35 + (trebVar-0.5)*0.22, 0, 1);
    const lpHz = lerp(5200, 15000, trebleBreathe);
    masterLP.frequency.setTargetAtTime(lpHz, t, 0.15);

    // noise follows lofi + a little dens
    noiseGain.gain.setTargetAtTime(lerp(0.004, 0.032, lofi) * lerp(0.85, 1.15, dens), t, 0.2);

    // crusher follows lofi; downsample follows drift
    const crushAmt = clamp(lerp(0.20, 0.86, lofi), 0, 1);
    const ds = 3 + Math.floor(lerp(2, 18, clamp((drift*0.5+0.5),0,1)));
    bitCrusher.set(crushAmt, ds);

    // IMPORTANT: set wet/dry explicitly from lofi (so it updates live correctly)
    const wet = lerp(0.12, 0.62, lofi);
    lofiMix.wet.gain.setTargetAtTime(wet, t, 0.1);
    lofiMix.dry.gain.setTargetAtTime(1 - wet, t, 0.1);

    // tape modulation (also influenced by fxDelay)
    tapeWowGain.gain.setTargetAtTime(lerp(0.0009, 0.0038, clamp(0.5+wow*0.35,0,1)) * lerp(0.7, 1.35, fxDelay), t, 0.2);
    tapeFlutterGain.gain.setTargetAtTime(lerp(0.00012,0.0006, clamp(0.5+flutter*0.35,0,1)) * lerp(0.7, 1.35, fxDelay), t, 0.2);

    tapeDelay.delayTime.setTargetAtTime(lerp(0.095, 0.180, clamp(0.5+drift*0.25,0,1)), t, 0.2);

    // FX sliders (live)
    delaySend.gain.setTargetAtTime(lerp(0.04, 0.35, fxDelay), t, 0.12);
    tapeFB.gain.setTargetAtTime(lerp(0.10, 0.28, fxDelay), t, 0.15);

    reverbSend.gain.setTargetAtTime(lerp(0.02, 0.40, fxReverb), t, 0.18);
    reverbGain.gain.setTargetAtTime(lerp(0.0, 0.55, fxReverb), t, 0.18);

    chorusMix.gain.setTargetAtTime(lerp(0.0, 0.45, fxChorus), t, 0.18);
    chorusDepth.gain.setTargetAtTime(lerp(0.0015, 0.0065, fxChorus), t, 0.18);
    chorusLFO.frequency.setTargetAtTime(lerp(0.12, 0.32, fxChorus), t, 0.18);

    // harmony
    const scale = scaleForMode(state.keyRoot, state.mode);
    const prog = state.useAlt ? state.progAlt : state.prog;
    const chordDeg = prog[bar % prog.length];
    const chord = chordFromDegree(scale, chordDeg, 0);

    // voicing drift + treble randomness makes occasional octave flips
    const voicingShift = Math.round(clamp(drift*2, -2, 2));
    const voiced = chord.map((m,i)=> {
      let x = m + (i===0 ? -12 : 0) + voicingShift;
      if (i===3 && Math.random() < 0.35*trebVar) x += 12;
      return x;
    });

    // ----- drums -----
    const s = step % 16;

    if (s === 0 || (s === 8 && Math.random() < lerp(0.75, 0.45, lofi)) ||
        (s === 12 && Math.random() < 0.15*dens)) {
      playKick(t);
    }

    if (s === 4 || s === 12) {
      playSnare(t, lerp(1850, 2500, clamp(0.5+bright*0.4,0,1)));
    } else if ((s === 14 || s === 6) && Math.random() < 0.08*dens) {
      playSnare(t, 2800);
    }

    const hatProb = lerp(0.25, 0.92, dens);
    if (Math.random() < hatProb && (s % 2 === 0)) playHat(t, lerp(0.03, 0.07, lofi));
    if (Math.random() < 0.2*dens && (s % 4 === 3)) playHat(t, lerp(0.05, 0.11, lofi));

    // ----- chords -----
    if (s === 0 || s === 8) {
      const chordBright = clamp(0.45 + bright*0.35 + (trebVar-0.5)*0.18, 0, 1);
      playChord(t, secondsPerBeat()*2.0, voiced, chordBright);
    } else if (s === 15 && Math.random() < 0.15*dens) {
      playChord(t, secondsPerBeat()*1.0, voiced, clamp(0.35 + bright*0.35, 0, 1));
    }

    // ----- bass -----
    // bass randomness affects probability of passing notes + note choices
    if (s === 0 || s === 8) {
      const root = voiced[0];
      playBass(t, secondsPerBeat()*1.75, root, lofi, bassVar);
    }

    const passProb = (0.18 + 0.26*bassVar) * dens;
    if ((s === 6 || s === 14) && Math.random() < passProb) {
      const nextDeg = prog[(bar+1) % prog.length];
      const nextChord = chordFromDegree(scale, nextDeg, 0);
      const target = nextChord[0]-12;
      const stepChoices = bassVar > 0.55 ? [-5,-3,-2,-1,1,2,3,5] : [-2,-1,1,2];
      const pass = quantToScale(target + choose(stepChoices), scale);
      playBass(t, secondsPerBeat()*0.75, pass, lofi, bassVar);
    }

    // ----- lead (treble randomness changes density + interval leaps) -----
    const leadProb = (0.08 + 0.18*trebVar) * dens;
    if (Math.random() < leadProb && (s === 2 || s === 10 || s === 14)) {
      const chordTones = [voiced[1], voiced[2], voiced[3]];
      let note = choose(chordTones) + choose([0,12,12,24]);
      const leap = choose(trebVar>0.6 ? [-7,-5,-2,2,5,7,12] : [-2,-1,1,2,5]);
      if (Math.random() < 0.5*trebVar) note += leap;
      note = quantToScale(note, scale);
      playLead(t, secondsPerBeat()*0.5, note, clamp(0.45 + bright*0.4, 0, 1), trebVar);
    }
  }

  // ---------- UI: live slider binding ----------
  function bindSlider(id, key, outId, fmt=(x)=>x.toFixed(2)) {
    const el = document.getElementById(id);
    const out= document.getElementById(outId);
    const set = () => { state[key] = +el.value; out.textContent = (id==="tempo") ? String(el.value) : fmt(+el.value); };
    el.addEventListener("input", set);
    set();
  }

  bindSlider("tempo","bpm","tempoVal",(x)=>String(Math.round(x)));
  bindSlider("lofi","lofi","lofiVal");
  bindSlider("dens","density","densVal");
  bindSlider("bassVar","bassVar","bassVarVal");
  bindSlider("trebleVar","trebleVar","trebleVarVal");
  bindSlider("fxDelay","fxDelay","fxDelayVal");
  bindSlider("fxReverb","fxReverb","fxReverbVal");
  bindSlider("fxChorus","fxChorus","fxChorusVal");

  // ---------- start/stop ----------
  document.getElementById("start").onclick = async () => {
    if (isRunning) return;
    if (!ac) makeAC();
    await ac.resume();

    isRunning = true;
    document.getElementById("start").disabled = true;
    document.getElementById("stop").disabled = false;

    state.bar = 0; state.step = 0;
    state.nextTime = ac.currentTime + 0.05;

    state.drift   = {v:0,dv:0};
    state.bright  = {v:0,dv:0};
    state.wow     = {v:0,dv:0};
    state.flutter = {v:0,dv:0};
    state.swing   = {v:0,dv:0};

    master.gain.setValueAtTime(0.9, ac.currentTime);

    timer = setInterval(scheduleAhead, 25);
  };

  document.getElementById("stop").onclick = () => {
    if (!isRunning) return;
    isRunning = false;
    clearInterval(timer); timer = null;

    const t = ac.currentTime;
    master.gain.setTargetAtTime(0.0001, t, 0.15);
    setTimeout(() => {
      try { ac.suspend(); } catch {}
      master.gain.setValueAtTime(0.9, ac.currentTime);
    }, 450);

    document.getElementById("start").disabled = false;
    document.getElementById("stop").disabled = true;
  };

  // ---------- FRACTAL: Julia set driven by music ----------
  const canvas = document.getElementById("fractal");
  const ctx = canvas.getContext("2d", { alpha: false });
  const W = canvas.width, H = canvas.height;
  const img = ctx.createImageData(W, H);
  let lastFrame = 0;

  // derived "music variables" used by the fractal
  const vis = {
    drift: 0, bright: 0, wow: 0, flutter: 0, swing: 0
  };

  function updateVisFromMusic() {
    // use the same wander states (even if not running, they’ll sit near 0)
    vis.drift   = state.drift.v;
    vis.bright  = state.bright.v;
    vis.wow     = state.wow.v;
    vis.flutter = state.flutter.v;
    vis.swing   = state.swing.v;
  }

  // tiny HSV->RGB for psychedelic coloring
  function hsv2rgb(h,s,v){
    h = ((h%1)+1)%1;
    const i = Math.floor(h*6);
    const f = h*6 - i;
    const p = v*(1-s);
    const q = v*(1-f*s);
    const t = v*(1-(1-f)*s);
    let r,g,b;
    switch(i%6){
      case 0: r=v,g=t,b=p; break;
      case 1: r=q,g=v,b=p; break;
      case 2: r=p,g=v,b=t; break;
      case 3: r=p,g=q,b=v; break;
      case 4: r=t,g=p,b=v; break;
      case 5: r=v,g=p,b=q; break;
    }
    return [r,g,b];
  }

  function renderFractal(timeMs) {
    // throttle a bit to keep CPU sane
    if (timeMs - lastFrame < 60) { requestAnimationFrame(renderFractal); return; }
    lastFrame = timeMs;

    updateVisFromMusic();

    const lofi = state.lofi;
    const dens = state.density;

    // music-driven Julia parameters
    const t = timeMs * 0.00008;
    const wow = vis.wow*0.5+0.5;
    const flutter = vis.flutter*0.5+0.5;
    const drift = vis.drift*0.5+0.5;
    const bright = vis.bright*0.5+0.5;

    const bassVar = state.bassVar;
    const trebleVar = state.trebleVar;

    // Julia constant c = a + bi
    const a = lerp(-0.82, -0.62, drift) + 0.06*Math.sin(t*2 + wow*3);
    const b = lerp( 0.12,  0.32, bright) + 0.06*Math.cos(t*2.4 + flutter*4);

    // zoom and rotation
    const zoom = lerp(1.4, 2.8, lofi) * lerp(0.85, 1.25, bassVar);
    const rot = t*0.9 + (trebleVar-0.5)*1.2;

    const cosr = Math.cos(rot), sinr = Math.sin(rot);

    // iterations driven by density
    const maxIter = Math.floor(lerp(52, 140, dens));
    const escape = 4.0;

    const data = img.data;
    let idx = 0;

    for (let y=0; y<H; y++){
      const ny = (y/H - 0.5) * 2;
      for (let x=0; x<W; x++){
        const nx = (x/W - 0.5) * 2;

        // rotate + scale
        let zx = (nx*cosr - ny*sinr) / zoom;
        let zy = (nx*sinr + ny*cosr) / zoom;

        let i = 0;
        for (; i<maxIter; i++){
          // z = z^2 + c
          const zx2 = zx*zx - zy*zy + a;
          const zy2 = 2*zx*zy + b;
          zx = zx2; zy = zy2;
          if (zx*zx + zy*zy > escape) break;
        }

        // color
        const norm = i / maxIter;
        const hue = (t*0.08 + norm*0.9 + wow*0.1 + trebleVar*0.15) % 1;
        const sat = clamp(0.65 + 0.30*dens + 0.15*trebleVar, 0, 1);
        const val = clamp(0.15 + 0.85*Math.pow(1-norm, 0.55) * lerp(0.9, 1.05, 1-lofi), 0, 1);

        const [r,g,b2] = hsv2rgb(hue, sat, val);

        // subtle “grain” tied to lofi
        const grain = (Math.random()-0.5) * 0.10 * lofi;

        data[idx++] = clamp((r+grain)*255, 0, 255);
        data[idx++] = clamp((g+grain)*255, 0, 255);
        data[idx++] = clamp((b2+grain)*255, 0, 255);
        data[idx++] = 255;
      }
    }
    ctx.putImageData(img, 0, 0);
    requestAnimationFrame(renderFractal);
  }
  requestAnimationFrame(renderFractal);

})();
</script>
</body>
</html>
