<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NOS-GOLD Music Generator</title>
  <style>
    :root{ color-scheme:dark; }
    html,body{ height:100%; }
    body{
      margin:0;
      background: radial-gradient(1200px 900px at 20% 10%, #111b2b 0%, #07080c 55%, #05060a 100%);
      color:#eaeaea;
      font-family: "Papyrus","Comic Sans MS","Brush Script MT",cursive;
      letter-spacing:.2px;
      text-shadow: 0 0 12px rgba(140,180,255,.16), 0 0 2px rgba(255,255,255,.10);
    }

    .app{
      display:grid;
      grid-template-columns: minmax(380px, 1fr) minmax(360px, 560px);
      gap: 12px;
      height: 100vh;
      padding: 14px;
      box-sizing:border-box;
    }

    .panel{
      background: rgba(10,14,22,.75);
      border: 1px solid rgba(120,170,255,.18);
      border-radius: 18px;
      box-shadow: 0 12px 34px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      overflow:hidden;
    }

    .left{
      display:flex;
      flex-direction:column;
      min-height:0;
    }

    .leftHeader{
      padding: 12px 14px 10px;
      border-bottom: 1px solid rgba(200,220,255,.12);
    }

    h1{
      margin: 0 0 10px;
      font-size: 28px;
      letter-spacing: 1px;
      filter: drop-shadow(0 0 12px rgba(170,90,255,.24));
    }

    .btns{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    button{
      border:0;
      border-radius: 14px;
      padding: 10px 14px;
      background: linear-gradient(180deg, rgba(240,240,255,.92), rgba(200,210,255,.88));
      color:#07080c;
      cursor:pointer;
      box-shadow: 0 10px 26px rgba(0,0,0,.26);
      font-family: inherit;
      font-size: 16px;
    }
    button:disabled{ opacity:.6; cursor:not-allowed; }

    .seedRow{
      margin-top:10px;
      display:grid;
      grid-template-columns: 1fr;
      gap:8px;
    }
    .seedRow input[type="text"]{
      width: 100%;
      box-sizing:border-box;
      border-radius: 14px;
      padding: 10px 12px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(200,220,255,.18);
      color:#eaeaea;
      outline:none;
      font-family: inherit;
      font-size: 15px;
    }
    .seedHint{
      font-size: 12px;
      opacity:.85;
      padding-left:2px;
    }

    .scroll{
      overflow:auto;
      padding: 10px 12px 16px;
    }

    .groupTitle{
      margin-top:10px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(200,220,255,.12);
      font-size: 15px;
      letter-spacing: .6px;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .row{
      display:grid;
      grid-template-columns: 140px 1fr 62px;
      gap: 10px;
      align-items:center;
    }

    .row label{ opacity:.95; }
    input[type="range"]{
      width:100%;
      accent-color: #a7d1ff;
    }
    .v{ text-align:right; opacity:.9; }

    /* Right panel (static) */
    .right{
      position: relative;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .rightHeader{
      padding: 12px 14px 10px;
      border-bottom: 1px solid rgba(200,220,255,.12);
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    .rightHeader .row{ grid-template-columns: 120px 1fr 62px; }

    .canvasWrap{
      position:relative;
      flex:1;
      min-height:0;
      padding: 12px;
      display:flex;
      justify-content:center;
      align-items:center;
    }
    canvas{
      border-radius: 18px;
      border: 1px solid rgba(120,170,255,.18);
      background:#000;
      box-shadow: 0 16px 46px rgba(0,0,0,.45);
      display:block;
      image-rendering: pixelated;
    }
    #fractalDisplay{
      width: min(96%, 520px);
      height: auto;
      aspect-ratio: 1 / 1;
    }
    #textOverlay{
      position:absolute;
      width: min(96%, 520px);
      height: auto;
      aspect-ratio: 1 / 1;
      pointer-events:none;
      mix-blend-mode: screen;
      filter: drop-shadow(0 0 10px rgba(255,255,255,.14));
    }

    @media (max-width: 980px){
      .app{ grid-template-columns: 1fr; height:auto; }
      .right{ position: static; }
      .canvasWrap{ padding: 12px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel left">
      <div class="leftHeader">
        <h1>NOS-GOLD Music Generator</h1>
        <div class="btns">
          <button id="start">Start</button>
          <button id="stop" disabled>Stop</button>
          <button id="regen">Regen Seed Phrase</button>
        </div>
        <div class="seedRow">
          <input id="seed" type="text" maxlength="100" placeholder="Seed text (up to 100 chars)">
          <div class="seedHint">Type something random here to help randomize the song.</div>
        </div>
      </div>

      <div class="scroll">
        <div class="controls">

          <div class="groupTitle">Master</div>
          <div class="row"><label>Tempo</label><input id="tempo" type="range" min="55" max="160" value="92"><div class="v" id="tempoV"></div></div>
          <div class="row"><label>Master</label><input id="master" type="range" min="0" max="1" step="0.01" value="0.85"><div class="v" id="masterV"></div></div>
          <div class="row"><label>Swing</label><input id="swing" type="range" min="0" max="1" step="0.01" value="0.40"><div class="v" id="swingV"></div></div>
          <div class="row"><label>Density</label><input id="dens" type="range" min="0" max="1" step="0.01" value="0.70"><div class="v" id="densV"></div></div>
          <div class="row"><label>Lo-Fi</label><input id="lofi" type="range" min="0" max="1" step="0.01" value="0.30"><div class="v" id="lofiV"></div></div>
          <div class="row"><label>Stereo</label><input id="stereo" type="range" min="0" max="1" step="0.01" value="0.55"><div class="v" id="stereoV"></div></div>

          <div class="groupTitle">EQ</div>
          <div class="row"><label>Bass</label><input id="bass" type="range" min="-12" max="12" step="0.1" value="2.0"><div class="v" id="bassV"></div></div>
          <div class="row"><label>Treble</label><input id="treble" type="range" min="-12" max="12" step="0.1" value="-1.0"><div class="v" id="trebleV"></div></div>

          <div class="groupTitle">FX</div>
          <div class="row"><label>Delay</label><input id="fxDelay" type="range" min="0" max="1" step="0.01" value="0.38"><div class="v" id="fxDelayV"></div></div>
          <div class="row"><label>Reverb</label><input id="fxReverb" type="range" min="0" max="1" step="0.01" value="0.28"><div class="v" id="fxReverbV"></div></div>
          <div class="row"><label>Chorus</label><input id="fxChorus" type="range" min="0" max="1" step="0.01" value="0.22"><div class="v" id="fxChorusV"></div></div>
          <div class="row"><label>Drive</label><input id="fxDrive" type="range" min="0" max="1" step="0.01" value="0.20"><div class="v" id="fxDriveV"></div></div>

          <div class="groupTitle">Phrase + Mutation</div>
          <div class="row"><label>Mutate</label><input id="mutate" type="range" min="0" max="1" step="0.01" value="0.78"><div class="v" id="mutateV"></div></div>
          <div class="row"><label>Key Drift</label><input id="keyDrift" type="range" min="0" max="1" step="0.01" value="0.70"><div class="v" id="keyDriftV"></div></div>
          <div class="row"><label>Phrase Len</label><input id="phraseLen" type="range" min="4" max="16" step="1" value="10"><div class="v" id="phraseLenV"></div></div>
          <div class="row"><label>Lead Busy</label><input id="leadBusy" type="range" min="0" max="1" step="0.01" value="0.62"><div class="v" id="leadBusyV"></div></div>

          <div class="groupTitle">Dub / Noise</div>
          <div class="row"><label>Grime</label><input id="grime" type="range" min="0" max="1" step="0.01" value="0.00"><div class="v" id="grimeV"></div></div>
          <div class="row"><label>Wub</label><input id="wub" type="range" min="0" max="1" step="0.01" value="0.00"><div class="v" id="wubV"></div></div>
          <div class="row"><label>Wub Rate</label><input id="wubRate" type="range" min="0.2" max="12" step="0.01" value="2.8"><div class="v" id="wubRateV"></div></div>
          <div class="row"><label>Wub Depth</label><input id="wubDepth" type="range" min="0" max="1" step="0.01" value="0.55"><div class="v" id="wubDepthV"></div></div>

          <div class="groupTitle">Mix</div>
          <div class="row"><label>Drums</label><input id="mixDrums" type="range" min="0" max="1" step="0.01" value="0.85"><div class="v" id="mixDrumsV"></div></div>
          <div class="row"><label>Kick</label><input id="mixKick" type="range" min="0" max="1" step="0.01" value="0.95"><div class="v" id="mixKickV"></div></div>
          <div class="row"><label>Snare</label><input id="mixSnare" type="range" min="0" max="1" step="0.01" value="0.62"><div class="v" id="mixSnareV"></div></div>
          <div class="row"><label>Hats</label><input id="mixHats" type="range" min="0" max="1" step="0.01" value="0.32"><div class="v" id="mixHatsV"></div></div>

          <div class="row"><label>Chords</label><input id="mixChords" type="range" min="0" max="1" step="0.01" value="0.60"><div class="v" id="mixChordsV"></div></div>
          <div class="row"><label>Bass</label><input id="mixBass" type="range" min="0" max="1" step="0.01" value="0.70"><div class="v" id="mixBassV"></div></div>
          <div class="row"><label>Lead</label><input id="mixLead" type="range" min="0" max="1" step="0.01" value="0.35"><div class="v" id="mixLeadV"></div></div>
          <div class="row"><label>Noise</label><input id="mixNoise" type="range" min="0" max="1" step="0.01" value="0.14"><div class="v" id="mixNoiseV"></div></div>

        </div>
      </div>
    </div>

    <div class="panel right">
      <div class="rightHeader">
        <div class="row"><label>Fractal</label>
          <input id="fractalType" type="range" min="0" max="9" step="1" value="0">
          <div class="v" id="fractalTypeV"></div>
        </div>
        <div class="row"><label>Auto 30s</label><input id="autoFractal" type="range" min="0" max="1" step="1" value="0"><div class="v" id="autoFractalV"></div></div>
        <div class="row"><label>Quality</label><input id="fractalQuality" type="range" min="0" max="1" step="0.01" value="0.25"><div class="v" id="fractalQualityV"></div></div>
        <div class="row"><label>Text Count</label><input id="wordCount" type="range" min="8" max="48" step="1" value="18"><div class="v" id="wordCountV"></div></div>
        <div class="row"><label>Text Warp</label><input id="wordWarp" type="range" min="0" max="1" step="0.01" value="0.45"><div class="v" id="wordWarpV"></div></div>
        <div class="row"><label>Text Speed</label><input id="wordSpeed" type="range" min="0" max="1" step="0.01" value="0.55"><div class="v" id="wordSpeedV"></div></div>
      </div>

      <div class="canvasWrap">
        <canvas id="fractalDisplay" width="520" height="520"></canvas>
        <canvas id="textOverlay" width="520" height="520"></canvas>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- utils ----------
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const nowMs = ()=>performance.now();
  const mtof  = (m)=>440*Math.pow(2,(m-69)/12);

  function xmur3(str){
    let h = 1779033703 ^ str.length;
    for (let i=0;i<str.length;i++){
      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      h = (h << 13) | (h >>> 19);
    }
    return function(){
      h = Math.imul(h ^ (h >>> 16), 2246822507);
      h = Math.imul(h ^ (h >>> 13), 3266489909);
      h ^= (h >>> 16);
      return h >>> 0;
    };
  }
  function mulberry32(a){
    return function(){
      a |= 0;
      a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function smoothWander(st, step=0.01, pull=0.002){
    st.dv += (Math.random()*2-1)*step - st.v*pull;
    st.dv *= 0.995;
    st.v += st.dv;
    return st.v;
  }

  // ---------- UI state ----------
  const S = {
    seedText: "",
    bpm: 92, master:0.85, swing:0.40, density:0.70, lofi:0.30, stereo:0.55,
    bassEQ:2.0, trebleEQ:-1.0,
    fxDelay:0.38, fxReverb:0.28, fxChorus:0.22, fxDrive:0.20,
    mutate:0.78, keyDrift:0.70, phraseLen:10, leadBusy:0.62,
    grime:0.00, wub:0.00, wubRate:2.8, wubDepth:0.55,
    mixDrums:0.85, mixKick:0.95, mixSnare:0.62, mixHats:0.32,
    mixChords:0.60, mixBass:0.70, mixLead:0.35, mixNoise:0.14,

    fractalType:0, autoFractal:0, fractalQuality:0.25,
    wordCount:18, wordWarp:0.45, wordSpeed:0.55,

    // music clock
    bar:0, step:0, nextTime:0,
    keyRoot:57, mode:"minor",
    drift:{v:0,dv:0}, bright:{v:0,dv:0}, wow:{v:0,dv:0}, flutter:{v:0,dv:0}, swingW:{v:0,dv:0},

    // seeded RNG + patterns
    rng: Math.random,
    phrase: [],
    phraseIdx: 0,
    drum: { kick: new Array(16).fill(0), snare:new Array(16).fill(0), hat:new Array(16).fill(0) },
    prog: [0,5,3,6],
    progAlt:[0,3,4,5],
    useAlt:false
  };

  const UI = {};
  function bindRange(id, key, fmt=(v)=>v.toFixed(2)){
    const el = document.getElementById(id);
    const out= document.getElementById(id+"V");
    UI[id]=el;
    const set=()=>{
      S[key]=+el.value;
      if(out){
        if(id==="tempo") out.textContent = String(Math.round(S[key]));
        else if(id==="phraseLen"||id==="wordCount"||id==="fractalType"||id==="autoFractal") out.textContent = String(Math.round(S[key]));
        else if(id==="bass"||id==="treble") out.textContent = (+S[key]).toFixed(1);
        else if(id==="wubRate") out.textContent = (+S[key]).toFixed(2);
        else out.textContent = fmt(+S[key]);
      }
    };
    el.addEventListener("input", set, {passive:true});
    set();
  }

  // bind sliders
  bindRange("tempo","bpm",(v)=>String(Math.round(v)));
  bindRange("master","master");
  bindRange("swing","swing");
  bindRange("dens","density");
  bindRange("lofi","lofi");
  bindRange("stereo","stereo");
  bindRange("bass","bassEQ",(v)=>v.toFixed(1));
  bindRange("treble","trebleEQ",(v)=>v.toFixed(1));
  bindRange("fxDelay","fxDelay");
  bindRange("fxReverb","fxReverb");
  bindRange("fxChorus","fxChorus");
  bindRange("fxDrive","fxDrive");
  bindRange("mutate","mutate");
  bindRange("keyDrift","keyDrift");
  bindRange("phraseLen","phraseLen",(v)=>String(Math.round(v)));
  bindRange("leadBusy","leadBusy");
  bindRange("grime","grime");
  bindRange("wub","wub");
  bindRange("wubRate","wubRate",(v)=>v.toFixed(2));
  bindRange("wubDepth","wubDepth");
  bindRange("mixDrums","mixDrums");
  bindRange("mixKick","mixKick");
  bindRange("mixSnare","mixSnare");
  bindRange("mixHats","mixHats");
  bindRange("mixChords","mixChords");
  bindRange("mixBass","mixBass");
  bindRange("mixLead","mixLead");
  bindRange("mixNoise","mixNoise");
  bindRange("fractalType","fractalType",(v)=>String(Math.round(v)));
  bindRange("autoFractal","autoFractal",(v)=>String(Math.round(v)));
  bindRange("fractalQuality","fractalQuality");
  bindRange("wordCount","wordCount",(v)=>String(Math.round(v)));
  bindRange("wordWarp","wordWarp");
  bindRange("wordSpeed","wordSpeed");

  // seed input
  const seedEl = document.getElementById("seed");
  seedEl.addEventListener("input", ()=>{
    S.seedText = seedEl.value.slice(0,100);
  }, {passive:true});

  // ---------- music theory helpers ----------
  function secondsPerBeat(){ return 60 / S.bpm; }
  const STEPS_PER_BAR = 16;

  function scaleForMode(rootMidi, mode) {
    const MAJ = [0,2,4,5,7,9,11];
    const MIN = [0,2,3,5,7,8,10];
    return (mode==="major"?MAJ:MIN).map(i => rootMidi+i);
  }
  function chordFromDegree(scale, degIndex, oct=0){
    const d = degIndex%7;
    const root = scale[d] + oct*12;
    const third = scale[(d+2)%7] + (d+2>=7?12:0) + oct*12;
    const fifth = scale[(d+4)%7] + (d+4>=7?12:0) + oct*12;
    const seventh= scale[(d+6)%7] + (d+6>=7?12:0) + oct*12;
    return [root,third,fifth,seventh];
  }
  function quantToScale(m, scale){
    const pc = ((m%12)+12)%12;
    const pcs = scale.map(x=>((x%12)+12)%12);
    let best=pcs[0], bestD=99;
    for(const p of pcs){
      const d=Math.min((pc-p+12)%12,(p-pc+12)%12);
      if(d<bestD){bestD=d;best=p;}
    }
    return m + (((best-pc)+12)%12);
  }

  // ---------- seeded generation ----------
  function reseedFromText(txt){
    const h = xmur3(txt || "NOS-GOLD");
    const a = h();
    S.rng = mulberry32(a);
  }
  function r(){ return S.rng(); }
  function ri(n){ return (r()*n)|0; }
  function choose(arr){ return arr[ri(arr.length)]; }

  function regenPhraseAndBeats(){
    reseedFromText(S.seedText || seedEl.value || "NOS-GOLD");
    const len = clamp(S.phraseLen|0, 4, 16);

    // phrase degrees 0..6, with "seeded contour"
    const phrase = [];
    let d = choose([0,2,4,5]);
    for(let i=0;i<len;i++){
      const jump = choose([-3,-2,-1,0,1,2,3,4,-4]);
      if (r() < 0.22) d = choose([0,2,4,5]);
      else d = clamp(d + jump, 0, 6);
      phrase.push(d);
    }
    phrase[len-1] = choose([0,2,4]);
    S.phrase = phrase;
    S.phraseIdx = 0;

    // drums: seeded base patterns
    const kick = new Array(16).fill(0);
    const snare= new Array(16).fill(0);
    const hat  = new Array(16).fill(0);

    // kick: anchor + seeded syncopation
    kick[0]=1; kick[8]=1;
    if (r()<0.65) kick[6]=0.6;
    if (r()<0.55) kick[10]=0.6;
    if (r()<0.45) kick[12]=0.5;
    if (r()<0.35) kick[14]=0.35;

    // snare: backbeat + seeded ghosts
    snare[4]=1; snare[12]=1;
    if (r()<0.50) snare[3]=0.35;
    if (r()<0.50) snare[15]=0.35;
    if (r()<0.35) snare[7]=0.28;

    // hats: 8ths + 16th spice
    for (let i=0;i<16;i+=2) hat[i]=0.85;
    for (let i=1;i<16;i+=2) if (r()<0.35) hat[i]=0.55;

    S.drum.kick = kick;
    S.drum.snare= snare;
    S.drum.hat  = hat;

    // seed-ish key/mode
    S.keyRoot = 45 + ri(28); // A2..G#4-ish
    S.mode = (r()<0.75) ? "minor" : "major";
    S.useAlt = r()<0.35;
  }

  // ---------- WebAudio ----------
  let ac=null, running=false, timer=null;

  let masterG, masterComp, masterSat, masterHP, masterLP;
  let bassEQ, trebleEQ;
  let drumBus, musicBus, drumsMixG, musicMixG;

  let delayNode, delaySendG, delayFBG;
  let revConvolver, revSendG, revWetG;
  let chorusDelay, chorusLFO, chorusDepthG, chorusWetG;
  let noiseGain, noiseSrc;
  let wubLFO, wubDepthG;
  let grimeDrive;
  let stereoMerger, stereoWidenerL, stereoWidenerR;
  let preMaster;

  let kickG, snareG, hatsG, chordsG, bassG, leadG;

  function makeSaturationCurve(amount=0.5){
    const n=4096;
    const curve=new Float32Array(n);
    const k=clamp(amount,0,1)*18+1;
    for(let i=0;i<n;i++){
      const x=(i*2/n)-1;
      curve[i]=Math.tanh(k*x)/Math.tanh(k);
    }
    return curve;
  }

  function makeImpulseResponse(seconds=1.6, decay=2.2){
    const rate = ac.sampleRate;
    const len = Math.floor(rate*seconds);
    const ir = ac.createBuffer(2, len, rate);
    for(let ch=0; ch<2; ch++){
      const d=ir.getChannelData(ch);
      for(let i=0;i<len;i++){
        const t=i/len;
        d[i]=(Math.random()*2-1)*Math.pow(1-t,decay);
      }
    }
    return ir;
  }

  function makeNoiseSrc(){
    const bufferSize = 2 * ac.sampleRate;
    const buffer = ac.createBuffer(1, bufferSize, ac.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<bufferSize;i++) data[i]=(Math.random()*2-1)*0.18;
    const src = ac.createBufferSource();
    src.buffer=buffer; src.loop=true; src.start();
    return src;
  }

  let clickBuf=null, snareBuf=null, hatBuf=null, clapBuf=null;
  function makeClickBuffer(){
    if (clickBuf) return clickBuf;
    const len=256;
    clickBuf=ac.createBuffer(1,len,ac.sampleRate);
    const d=clickBuf.getChannelData(0);
    for(let i=0;i<len;i++){
      const t=i/len;
      d[i]=(Math.random()*2-1)*Math.pow(1-t,6);
    }
    return clickBuf;
  }
  function makeSnareNoise(){
    if (snareBuf) return snareBuf;
    const len=(ac.sampleRate*0.32)|0;
    snareBuf=ac.createBuffer(1,len,ac.sampleRate);
    const d=snareBuf.getChannelData(0);
    for(let i=0;i<len;i++){
      const t=i/len;
      d[i]=(Math.random()*2-1)*Math.pow(1-t,3.0);
    }
    return snareBuf;
  }
  function makeHatNoise(){
    if (hatBuf) return hatBuf;
    const len=(ac.sampleRate*0.20)|0;
    hatBuf=ac.createBuffer(1,len,ac.sampleRate);
    const d=hatBuf.getChannelData(0);
    for(let i=0;i<len;i++){
      const t=i/len;
      d[i]=(Math.random()*2-1)*Math.pow(1-t,5.0);
    }
    return hatBuf;
  }
  function makeClapNoise(){
    if (clapBuf) return clapBuf;
    const len=(ac.sampleRate*0.22)|0;
    clapBuf=ac.createBuffer(1,len,ac.sampleRate);
    const d=clapBuf.getChannelData(0);
    for(let i=0;i<len;i++){
      const t=i/len;
      const burst = (t<0.10?1:0) + (t>0.12&&t<0.22?0.9:0) + (t>0.24&&t<0.40?0.7:0);
      d[i]=(Math.random()*2-1)*burst*Math.pow(1-t,2.4);
    }
    return clapBuf;
  }

  function envGain(t0, atk, dec, sus, rel, t1){
    const g=ac.createGain();
    const eps=0.0001;
    g.gain.setValueAtTime(eps,t0);
    g.gain.exponentialRampToValueAtTime(1.0,t0+atk);
    g.gain.exponentialRampToValueAtTime(Math.max(eps,sus),t0+atk+dec);
    g.gain.setValueAtTime(Math.max(eps,sus),t1);
    g.gain.exponentialRampToValueAtTime(eps,t1+rel);
    return g;
  }
  function pan(amount){
    const p=ac.createStereoPanner();
    p.pan.value = amount;
    return p;
  }

  function ensureAudio(){
    if (ac) return;
    ac = new (window.AudioContext || window.webkitAudioContext)();

    drumBus=ac.createGain();
    musicBus=ac.createGain();
    drumsMixG=ac.createGain();
    musicMixG=ac.createGain();
    drumBus.connect(drumsMixG);
    musicBus.connect(musicMixG);

    // stereo decorrelation
    stereoMerger = ac.createChannelMerger(2);
    stereoWidenerL = ac.createGain();
    stereoWidenerR = ac.createGain();

    const sumToStereo = ac.createGain();
    drumsMixG.connect(sumToStereo);
    musicMixG.connect(sumToStereo);

    const dl = ac.createDelay(0.03); dl.delayTime.value = 0.006;
    const dr = ac.createDelay(0.03); dr.delayTime.value = 0.011;
    sumToStereo.connect(dl); sumToStereo.connect(dr);
    dl.connect(stereoWidenerL); dr.connect(stereoWidenerR);
    stereoWidenerL.connect(stereoMerger,0,0);
    stereoWidenerR.connect(stereoMerger,0,1);

    preMaster = ac.createGain();
    stereoMerger.connect(preMaster);

    // EQ
    bassEQ=ac.createBiquadFilter(); bassEQ.type="lowshelf"; bassEQ.frequency.value=120;
    trebleEQ=ac.createBiquadFilter(); trebleEQ.type="highshelf"; trebleEQ.frequency.value=5200;

    // master chain
    masterHP=ac.createBiquadFilter(); masterHP.type="highpass"; masterHP.frequency.value=28;
    masterLP=ac.createBiquadFilter(); masterLP.type="lowpass"; masterLP.Q.value=0.55;

    masterSat=ac.createWaveShaper(); masterSat.curve=makeSaturationCurve(0.35); masterSat.oversample="2x";
    grimeDrive=ac.createWaveShaper(); grimeDrive.curve=makeSaturationCurve(0.35); grimeDrive.oversample="4x";

    masterComp=ac.createDynamicsCompressor();
    masterComp.threshold.value=-16;
    masterComp.knee.value=24;
    masterComp.ratio.value=3.0;
    masterComp.attack.value=0.01;
    masterComp.release.value=0.22;

    masterG=ac.createGain();
    masterG.gain.value=S.master;

    // FX: delay
    delayNode=ac.createDelay(1.0);
    delayFBG=ac.createGain();
    delaySendG=ac.createGain();
    delayNode.connect(delayFBG);
    delayFBG.connect(delayNode);

    // FX: reverb
    revConvolver=ac.createConvolver();
    revConvolver.buffer = makeImpulseResponse(1.6, 2.2);
    revSendG=ac.createGain();
    revWetG=ac.createGain();

    // FX: chorus
    chorusDelay=ac.createDelay(0.05);
    chorusDelay.delayTime.value=0.016;
    chorusLFO=ac.createOscillator(); chorusLFO.type="sine"; chorusLFO.frequency.value=0.22;
    chorusDepthG=ac.createGain(); chorusDepthG.gain.value=0.004;
    chorusWetG=ac.createGain();
    chorusLFO.connect(chorusDepthG);
    chorusDepthG.connect(chorusDelay.delayTime);
    chorusLFO.start();

    // noise
    noiseSrc=makeNoiseSrc();
    noiseGain=ac.createGain();
    const nHP=ac.createBiquadFilter(); nHP.type="highpass"; nHP.frequency.value=160;
    const nLP=ac.createBiquadFilter(); nLP.type="lowpass"; nLP.frequency.value=5200;
    noiseSrc.connect(nHP); nHP.connect(nLP); nLP.connect(noiseGain);

    // wub LFO
    wubLFO=ac.createOscillator(); wubLFO.type="sine"; wubLFO.frequency.value=S.wubRate;
    wubDepthG=ac.createGain(); wubDepthG.gain.value=0.0;
    wubLFO.connect(wubDepthG);
    wubLFO.start();

    // FX sends from preMaster
    preMaster.connect(delaySendG); delaySendG.connect(delayNode);
    preMaster.connect(revSendG);   revSendG.connect(revConvolver);
    preMaster.connect(chorusDelay); chorusDelay.connect(chorusWetG);
    revConvolver.connect(revWetG);

    // FX returns
    delayNode.connect(preMaster);
    revWetG.connect(preMaster);
    chorusWetG.connect(preMaster);
    noiseGain.connect(preMaster);

    // Tone chain
    preMaster.connect(bassEQ);
    bassEQ.connect(trebleEQ);
    trebleEQ.connect(grimeDrive);
    grimeDrive.connect(masterHP);
    masterHP.connect(masterLP);
    masterLP.connect(masterSat);
    masterSat.connect(masterComp);
    masterComp.connect(masterG);
    masterG.connect(ac.destination);

    // instrument gains
    kickG=ac.createGain(); snareG=ac.createGain(); hatsG=ac.createGain();
    chordsG=ac.createGain(); bassG=ac.createGain(); leadG=ac.createGain();
    kickG.connect(drumBus); snareG.connect(drumBus); hatsG.connect(drumBus);
    chordsG.connect(musicBus); bassG.connect(musicBus); leadG.connect(musicBus);
  }

  function applyLiveParams(t){
    masterG.gain.setTargetAtTime(S.master, t, 0.04);

    drumsMixG.gain.setTargetAtTime(S.mixDrums, t, 0.05);
    kickG.gain.setTargetAtTime(S.mixKick, t, 0.05);
    snareG.gain.setTargetAtTime(S.mixSnare, t, 0.05);
    hatsG.gain.setTargetAtTime(S.mixHats, t, 0.05);
    chordsG.gain.setTargetAtTime(S.mixChords, t, 0.05);
    bassG.gain.setTargetAtTime(S.mixBass, t, 0.05);
    leadG.gain.setTargetAtTime(S.mixLead, t, 0.05);

    noiseGain.gain.setTargetAtTime(lerp(0.002, 0.030, S.mixNoise) * lerp(0.85, 1.25, S.lofi), t, 0.10);

    bassEQ.gain.setTargetAtTime(S.bassEQ, t, 0.08);
    trebleEQ.gain.setTargetAtTime(S.trebleEQ, t, 0.08);

    const lpHz = lerp(6500, 18500, 1 - S.lofi);
    masterLP.frequency.setTargetAtTime(lpHz, t, 0.15);

    const wetDelay = lerp(0.0, 0.42, S.fxDelay);
    delaySendG.gain.setTargetAtTime(wetDelay, t, 0.10);
    delayFBG.gain.setTargetAtTime(lerp(0.06, 0.32, S.fxDelay), t, 0.12);
    delayNode.delayTime.setTargetAtTime(lerp(0.16, 0.46, S.fxDelay), t, 0.15);

    revSendG.gain.setTargetAtTime(lerp(0.0, 0.42, S.fxReverb), t, 0.12);
    revWetG.gain.setTargetAtTime(lerp(0.0, 0.55, S.fxReverb), t, 0.12);

    chorusWetG.gain.setTargetAtTime(lerp(0.0, 0.40, S.fxChorus), t, 0.12);
    chorusDepthG.gain.setTargetAtTime(lerp(0.0015, 0.0068, S.fxChorus), t, 0.12);
    chorusLFO.frequency.setTargetAtTime(lerp(0.12, 0.35, S.fxChorus), t, 0.12);

    masterSat.curve = makeSaturationCurve(lerp(0.12, 0.65, S.fxDrive));
    grimeDrive.curve = makeSaturationCurve(lerp(0.25, 0.98, S.grime) * lerp(0.35, 1.0, S.fxDrive));

    const wid = lerp(0.90, 1.38, S.stereo);
    stereoWidenerL.gain.setTargetAtTime(wid, t, 0.12);
    stereoWidenerR.gain.setTargetAtTime(wid, t, 0.12);

    wubLFO.frequency.setTargetAtTime(S.wubRate, t, 0.06);
    wubDepthG.gain.setTargetAtTime(S.wub>0.001 ? lerp(0.0, 2200, S.wubDepth*S.wub) : 0.0, t, 0.08);
  }

  // ---------- instruments ----------
  function playKick(t, v=1){
    // body
    const o=ac.createOscillator(); o.type="sine";
    const g=ac.createGain();
    const p=pan((Math.random()*2-1)*0.10*S.stereo);

    o.frequency.setValueAtTime(165, t);
    o.frequency.exponentialRampToValueAtTime(52, t+0.11);

    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(1.0*v, t+0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.32);

    // click
    const c=ac.createBufferSource(); c.buffer=makeClickBuffer();
    const cg=ac.createGain();
    cg.gain.setValueAtTime(0.18*v, t);
    cg.gain.exponentialRampToValueAtTime(0.0001, t+0.03);

    const ws=ac.createWaveShaper(); ws.curve=makeSaturationCurve(lerp(0.18,0.55,S.fxDrive));

    o.connect(g); g.connect(ws); ws.connect(p); p.connect(kickG);
    c.connect(cg); cg.connect(p);

    o.start(t); o.stop(t+0.5);
    c.start(t); c.stop(t+0.05);
  }

  function playSnare(t, v=1){
    const n=ac.createBufferSource(); n.buffer=makeSnareNoise();
    const bp=ac.createBiquadFilter(); bp.type="bandpass"; bp.frequency.value=1900 + Math.random()*900; bp.Q.value=0.7;
    const hp=ac.createBiquadFilter(); hp.type="highpass"; hp.frequency.value=500;
    const ng=ac.createGain();
    ng.gain.setValueAtTime(0.0001, t);
    ng.gain.exponentialRampToValueAtTime(0.9*v, t+0.006);
    ng.gain.exponentialRampToValueAtTime(0.0001, t+0.22);

    // body tone
    const o=ac.createOscillator(); o.type="triangle"; o.frequency.setValueAtTime(180 + (Math.random()*2-1)*20, t);
    const og=ac.createGain();
    og.gain.setValueAtTime(0.0001, t);
    og.gain.exponentialRampToValueAtTime(0.40*v, t+0.003);
    og.gain.exponentialRampToValueAtTime(0.0001, t+0.12);

    // clap spice
    if (Math.random() < 0.45){
      const c=ac.createBufferSource(); c.buffer=makeClapNoise();
      const chp=ac.createBiquadFilter(); chp.type="highpass"; chp.frequency.value=800;
      const cg=ac.createGain();
      cg.gain.setValueAtTime(0.0001, t);
      cg.gain.exponentialRampToValueAtTime(0.35*v, t+0.004);
      cg.gain.exponentialRampToValueAtTime(0.0001, t+0.24);
      c.connect(chp); chp.connect(cg); cg.connect(snareG);
      c.start(t); c.stop(t+0.30);
    }

    const p=pan((Math.random()*2-1)*0.12*S.stereo);
    const ws=ac.createWaveShaper(); ws.curve=makeSaturationCurve(lerp(0.15,0.60,S.fxDrive)*(1+0.7*S.grime));

    n.connect(bp); bp.connect(hp); hp.connect(ng);
    o.connect(og);

    ng.connect(ws); og.connect(ws);
    ws.connect(p); p.connect(snareG);

    n.start(t); n.stop(t+0.30);
    o.start(t); o.stop(t+0.16);
  }

  function playHat(t, open=0.06, v=1){
    const n=ac.createBufferSource(); n.buffer=makeHatNoise();
    const hp=ac.createBiquadFilter(); hp.type="highpass"; hp.frequency.value=6500 + Math.random()*2200; hp.Q.value=0.3;
    const bp=ac.createBiquadFilter(); bp.type="bandpass"; bp.frequency.value=8200 + Math.random()*3200; bp.Q.value=0.9;
    const g=ac.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.32*v, t+0.0015);
    g.gain.exponentialRampToValueAtTime(0.0001, t+open);
    const p=pan((Math.random()*2-1)*0.55*S.stereo);

    n.connect(hp); hp.connect(bp); bp.connect(g);
    g.connect(p); p.connect(hatsG);
    n.start(t); n.stop(t+open+0.03);
  }

  function playChord(t0, dur, chordMidi, bright=0.55, v=1){
    const out=ac.createGain(); out.gain.value=v;
    const lp=ac.createBiquadFilter(); lp.type="lowpass"; lp.Q.value=0.65;
    lp.frequency.setValueAtTime(lerp(900,6500,bright)*lerp(0.85,1.1,1-S.lofi), t0);
    const p=pan((Math.random()*2-1)*0.25*S.stereo);
    out.connect(lp); lp.connect(p); p.connect(chordsG);

    for (let i=0;i<chordMidi.length;i++){
      const m=chordMidi[i];
      const o1=ac.createOscillator(); o1.type="triangle";
      const o2=ac.createOscillator(); o2.type="sine";
      const det=(i-1.5)*(4+Math.random()*4) + (Math.random()*2-1)*2;
      o1.detune.value=det; o2.detune.value=det*0.35;
      const f=mtof(m);
      o1.frequency.setValueAtTime(f, t0);
      o2.frequency.setValueAtTime(f*0.5, t0);

      const g1=envGain(t0, 0.08, 0.35, 0.18, 0.35, t0+dur);
      const g2=envGain(t0, 0.12, 0.45, 0.12, 0.35, t0+dur);

      const m1=ac.createGain(); m1.gain.value=0.85;
      const m2=ac.createGain(); m2.gain.value=0.35;

      o1.connect(g1); g1.connect(m1); m1.connect(out);
      o2.connect(g2); g2.connect(m2); m2.connect(out);

      o1.start(t0); o2.start(t0);
      o1.stop(t0+dur+1.0); o2.stop(t0+dur+1.0);
    }
  }

  function playBass(t0, dur, midi, v=1){
    const o1=ac.createOscillator(); o1.type="sawtooth";
    const o2=ac.createOscillator(); o2.type="square";
    const f=mtof(midi);
    o1.frequency.setValueAtTime(f, t0);
    o2.frequency.setValueAtTime(f*0.5, t0);

    const lp=ac.createBiquadFilter(); lp.type="lowpass";
    lp.Q.value=lerp(0.9,2.4,S.wubDepth);
    const base = lerp(140, 720, 1-S.lofi) * lerp(0.85, 1.25, 0.5 + 0.7*S.density);
    lp.frequency.setValueAtTime(base, t0);
    wubDepthG.connect(lp.frequency);

    const g=envGain(t0, 0.006, 0.10, 0.22, 0.14, t0+dur);
    const ws=ac.createWaveShaper(); ws.curve=makeSaturationCurve(lerp(0.18,0.95,S.fxDrive)*(1+0.7*S.grime));

    const p=pan((Math.random()*2-1)*0.12*S.stereo);
    const m1=ac.createGain(); m1.gain.value=0.70;
    const m2=ac.createGain(); m2.gain.value=0.35;

    o1.connect(m1); o2.connect(m2);
    m1.connect(lp); m2.connect(lp);
    lp.connect(g); g.connect(ws); ws.connect(p); p.connect(bassG);

    o1.start(t0); o2.start(t0);
    o1.stop(t0+dur+0.4); o2.stop(t0+dur+0.4);
  }

  function playLead(t0, dur, midi, v=1){
    const o1=ac.createOscillator(); o1.type="sine";
    const o2=ac.createOscillator(); o2.type="triangle";
    const f=mtof(midi);
    o1.frequency.setValueAtTime(f, t0);
    o2.frequency.setValueAtTime(f*2, t0);

    const lfo=ac.createOscillator(); lfo.type="sine"; lfo.frequency.value=5.2 + (Math.random()*2-1)*1.2;
    const lfg=ac.createGain(); lfg.gain.value=lerp(6,22,S.leadBusy);
    lfo.connect(lfg); lfg.connect(o1.detune); lfg.connect(o2.detune);

    const g=envGain(t0, 0.004, 0.10, 0.08, 0.12, t0+dur);

    const bp=ac.createBiquadFilter(); bp.type="bandpass";
    bp.Q.value=1.1 + 0.9*S.leadBusy;
    bp.frequency.value = lerp(900, 3200, 0.45+0.45*S.leadBusy) * lerp(0.9, 1.2, 1-S.lofi);

    const ws=ac.createWaveShaper(); ws.curve=makeSaturationCurve(lerp(0.10,0.55,S.fxDrive)*(1+0.4*S.grime));
    const p=pan((Math.random()*2-1)*0.7*S.stereo);

    const mg=ac.createGain(); mg.gain.value=v;

    o1.connect(bp); o2.connect(bp);
    bp.connect(g); g.connect(ws); ws.connect(mg); mg.connect(p); p.connect(leadG);

    lfo.start(t0);
    o1.start(t0); o2.start(t0);
    o1.stop(t0+dur+0.35); o2.stop(t0+dur+0.35);
    lfo.stop(t0+dur+0.35);
  }

  // ---------- constant mutation (phrase + beats + key) ----------
  function mutatePhraseAndBeats(scale){
    const m = S.mutate;

    // phrase: mutate multiple indices constantly
    if (S.phrase.length){
      const changes = 1 + Math.floor(lerp(1, 6, m));
      for (let k=0;k<changes;k++){
        const i = ri(S.phrase.length);
        const delta = choose([-4,-3,-2,-1,1,2,3,4]);
        if (r() < 0.65) S.phrase[i] = clamp(S.phrase[i] + delta, 0, 6);
        else S.phrase[i] = choose([0,2,4,5,6]);
      }
      if (r() < 0.35*m) S.phrase[S.phrase.length-1] = choose([0,2,4]);
    }

    // drums: mutate probabilities per step
    const d = S.density;
    for (let i=0;i<16;i++){
      if (r() < 0.07*m){
        S.drum.kick[i] = clamp(S.drum.kick[i] + (r()*2-1)*0.5, 0, 1);
      }
      if (r() < 0.08*m){
        S.drum.hat[i] = clamp(S.drum.hat[i] + (r()*2-1)*0.6, 0, 1);
      }
      if (r() < 0.05*m){
        S.drum.snare[i] = clamp(S.drum.snare[i] + (r()*2-1)*0.5, 0, 1);
      }
      // keep backbeat sane-ish
      S.drum.snare[4]=1; S.drum.snare[12]=1;
      S.drum.kick[0]=1;
      if (d>0.4) S.drum.kick[8]=1;
    }

    // key drift: frequent gentle nudges + occasional lurch
    const kd = S.keyDrift;
    if (r() < (0.10 + 0.30*kd)){
      const shift = choose([-2,2,-5,5,-7,7,12,-12]);
      S.keyRoot = clamp(S.keyRoot + shift, 45, 72);
      if (r() < 0.25*kd) S.mode = (S.mode==="minor" ? "major" : "minor");
      if (r() < 0.35*kd) S.useAlt = !S.useAlt;
    }

    // re-seed RNG slightly over time using drift so it doesn't lock into loops
    if (r() < 0.10*m){
      const salt = Math.floor(1e9*Math.random()).toString(36);
      reseedFromText((S.seedText||"NOS-GOLD") + "|" + salt + "|" + (S.bar|0));
    }
  }

  function scheduleStep(t, step, bar){
    applyLiveParams(t);

    // wander
    smoothWander(S.drift,   0.004, 0.0015);
    smoothWander(S.bright,  0.006, 0.002);
    smoothWander(S.wow,     0.004, 0.0015);
    smoothWander(S.flutter, 0.004, 0.0015);
    smoothWander(S.swingW,  0.003, 0.0012);

    // wub affects bass filter only when enabled
    const wubOn = S.wub > 0.001;
    wubDepthG.gain.setTargetAtTime(wubOn ? lerp(0.0, 2200, S.wubDepth*S.wub) : 0.0, t, 0.05);

    const s = step % 16;
    const dens = S.density;

    const scale = scaleForMode(S.keyRoot, S.mode);
    const prog = S.useAlt ? S.progAlt : S.prog;
    const chordDeg = prog[bar % prog.length];
    const chord = chordFromDegree(scale, chordDeg, 0);

    // voicing drift
    const drift = S.drift.v;
    const voicingShift = Math.round(clamp(drift*3, -3, 3));
    const voiced = chord.map((m,i)=>{
      let x = m + (i===0 ? -12 : 0) + voicingShift;
      if (i===3 && Math.random() < 0.40*(0.2+S.leadBusy)) x += 12;
      if (i===1 && Math.random() < 0.22*(0.2+S.mutate)) x -= 12;
      return x;
    });

    // DRUMS from probabilistic pattern arrays
    const kickP = S.drum.kick[s] * lerp(0.55, 1.0, dens);
    const snrP  = S.drum.snare[s] * lerp(0.55, 1.0, dens);
    const hatP  = S.drum.hat[s] * lerp(0.45, 1.0, dens);

    if (kickP > 0 && Math.random() < kickP) playKick(t, lerp(0.65, 1.0, kickP));
    if (snrP  > 0 && Math.random() < snrP)  playSnare(t, lerp(0.35, 1.0, snrP));
    if (hatP  > 0 && Math.random() < hatP){
      const open = (s%4===3 && Math.random()<0.35*dens) ? 0.11 : lerp(0.035, 0.070, S.lofi);
      playHat(t, open, lerp(0.55, 1.0, hatP));
    }

    // CHORDS
    if (s===0 || s===8){
      const b = clamp(0.38 + 0.42*(S.bright.v*0.5+0.5) + 0.22*(1-S.lofi), 0, 1);
      playChord(t, secondsPerBeat()*2.0, voiced, b, 1.0);
    }
    if (s===15 && Math.random() < 0.35*dens){
      playChord(t, secondsPerBeat()*1.0, voiced, 0.45, 0.7);
    }

    // BASS (root + passing)
    if (s===0 || s===8){
      playBass(t, secondsPerBeat()*1.85, voiced[0], 1.0);
    }
    const passProb = (0.18 + 0.55*S.mutate) * dens;
    if ((s===6 || s===10 || s===14) && Math.random() < passProb){
      const nextDeg = prog[(bar+1)%prog.length];
      const nextChord = chordFromDegree(scale, nextDeg, 0);
      const target = nextChord[0]-12;
      const options = (S.mutate>0.5)
        ? [-12,-7,-5,-3,-2,-1,1,2,3,5,7,12]
        : [-5,-3,-2,-1,1,2,3,5];
      const pass = quantToScale(target + choose(options), scale);
      playBass(t, secondsPerBeat()*0.70, pass, 0.9);
    }

    // LEAD (phrase-driven, constantly mutating)
    if (S.phrase.length){
      const slot = (s===1||s===2||s===5||s===6||s===9||s===10||s===13||s===14);
      const leadGate = (0.10 + 0.35*S.leadBusy) * dens;
      if (slot && Math.random() < leadGate){
        const deg = S.phrase[S.phraseIdx % S.phrase.length];
        S.phraseIdx++;

        let note = scale[deg] + choose([12,12,24,0]);
        if (Math.random() < 0.55*S.mutate) note += choose([-12,-7,-5,-2,2,5,7,12]);
        note = quantToScale(note, scale);

        const dur = secondsPerBeat() * choose([0.25,0.5,0.5,0.75]);
        playLead(t, dur, note, lerp(0.50, 1.0, S.leadBusy));
      }
    }
  }

  function advanceStep(){
    S.step++;
    const sd = secondsPerBeat()/2;
    const swingAmt = lerp(0.0, 0.085, S.swing);
    const isOff = (S.step % 2) === 1;
    S.nextTime += sd + (isOff ? swingAmt : 0);

    if (S.step >= STEPS_PER_BAR){
      S.step = 0;
      S.bar++;

      const scale = scaleForMode(S.keyRoot, S.mode);
      mutatePhraseAndBeats(scale);

      // occasional regen from seed (keeps it evolving but anchored)
      if (Math.random() < 0.06 + 0.14*S.keyDrift){
        reseedFromText((S.seedText||"NOS-GOLD") + "|" + (S.bar|0));
      }
    }
  }

  function scheduleAhead(){
    if (!running) return;
    const now = ac.currentTime;
    const lookahead = 0.22;
    while (S.nextTime < now + lookahead){
      scheduleStep(S.nextTime, S.step, S.bar);
      advanceStep();
    }
  }

  // ---------- Fractal rendering (FAST) ----------
  const fractalDisplay = document.getElementById("fractalDisplay");
  const overlayCanvas  = document.getElementById("textOverlay");
  const dctx = fractalDisplay.getContext("2d", {alpha:false});
  const octx = overlayCanvas.getContext("2d", {alpha:true});

  // internal low-res render target (offscreen)
  const off = document.createElement("canvas");
  const fctx = off.getContext("2d", {alpha:false, willReadFrequently:true});

  const FRACTALS = ["mandelbrot","julia","burning_ship","tricorn","multibrot3","multibrot4","newton3","phoenix","celtic","spider"];
  function fractalName(i){ return FRACTALS[(i|0)%FRACTALS.length]; }
  function updateFractalTypeLabel(){
    const el = document.getElementById("fractalTypeV");
    if (el) el.textContent = fractalName(S.fractalType);
  }
  updateFractalTypeLabel();
  document.getElementById("fractalType").addEventListener("input", updateFractalTypeLabel, {passive:true});

  function hsv2rgb(h,s,v){
    h = ((h%1)+1)%1;
    const i = Math.floor(h*6);
    const f = h*6 - i;
    const p = v*(1-s);
    const q = v*(1-f*s);
    const t = v*(1-(1-f)*s);
    let r,g,b;
    switch(i%6){
      case 0: r=v,g=t,b=p; break;
      case 1: r=q,g=v,b=p; break;
      case 2: r=p,g=v,b=t; break;
      case 3: r=p,g=q,b=v; break;
      case 4: r=t,g=p,b=v; break;
      case 5: r=v,g=p,b=q; break;
    }
    return [r,g,b];
  }

  let lastFractalSwitch = nowMs();
  let lastFractalFrame = 0;

  function setOffRes(){
    // low-res by default; quality slider scales resolution modestly
    const q = S.fractalQuality; // 0..1
    const base = 220;           // default low-res
    const extra = 220;          // up to ~440
    const res = Math.round(base + extra*q);
    if (off.width !== res){
      off.width = off.height = res;
    }
  }

  function renderFractal(ts){
    // throttle: fractal at ~12–18 fps max
    const dt = ts - lastFractalFrame;
    const minFrame = lerp(80, 55, S.fractalQuality); // lower quality => fewer frames
    if (dt < minFrame){
      requestAnimationFrame(renderFractal);
      return;
    }
    lastFractalFrame = ts;

    if (S.autoFractal > 0.5 && (ts - lastFractalSwitch) > 30000){
      S.fractalType = (S.fractalType + 1 + ((Math.random()*9)|0)) % 10;
      UI.fractalType.value = S.fractalType;
      updateFractalTypeLabel();
      lastFractalSwitch = ts;
    }

    setOffRes();
    const W = off.width, H = off.height;
    const img = fctx.createImageData(W, H);
    const data = img.data;

    const t = ts * 0.00008;
    const dens = S.density;
    const drift = S.drift.v*0.5+0.5;
    const bright= S.bright.v*0.5+0.5;

    const zoom = lerp(1.2, 3.2, 0.35 + 0.65*S.lofi) * lerp(0.9, 1.2, 0.5 + 0.6*S.mutate);
    const rot = t*0.9 + (S.keyDrift-0.5)*1.7;
    const cosr = Math.cos(rot), sinr = Math.sin(rot);

    const maxIter = Math.floor(lerp(52, 140, dens) * lerp(0.75, 1.15, S.fractalQuality));
    const escape = 4.0;

    const ca = lerp(-0.82, -0.62, drift) + 0.08*Math.sin(t*2.0 + S.wubDepth*3.0);
    const cb = lerp( 0.10,  0.34, bright)+ 0.08*Math.cos(t*2.6 + S.fxChorus*4.0);

    const type = fractalName(S.fractalType);

    function iterate(x0,y0){
      let i=0;

      if (type==="mandelbrot"){
        let zx=0, zy=0;
        for(; i<maxIter; i++){
          const zx2 = zx*zx - zy*zy + x0;
          const zy2 = 2*zx*zy + y0;
          zx=zx2; zy=zy2;
          if (zx*zx + zy*zy > escape) break;
        }
        return i;
      }

      if (type==="julia"){
        let zx=x0, zy=y0;
        for(; i<maxIter; i++){
          const zx2 = zx*zx - zy*zy + ca;
          const zy2 = 2*zx*zy + cb;
          zx=zx2; zy=zy2;
          if (zx*zx + zy*zy > escape) break;
        }
        return i;
      }

      if (type==="burning_ship"){
        let zx=0, zy=0;
        for(; i<maxIter; i++){
          const ax = Math.abs(zx), ay = Math.abs(zy);
          const zx2 = ax*ax - ay*ay + x0;
          const zy2 = 2*ax*ay + y0;
          zx=zx2; zy=zy2;
          if (zx*zx + zy*zy > escape) break;
        }
        return i;
      }

      if (type==="tricorn"){
        let zx=0, zy=0;
        for(; i<maxIter; i++){
          const zx2 = zx*zx - zy*zy + x0;
          const zy2 = -2*zx*zy + y0;
          zx=zx2; zy=zy2;
          if (zx*zx + zy*zy > escape) break;
        }
        return i;
      }

      if (type==="multibrot3" || type==="multibrot4"){
        const p = (type==="multibrot3") ? 3 : 4;
        let zx=0, zy=0;
        for(; i<maxIter; i++){
          const rr = Math.sqrt(zx*zx + zy*zy);
          const aa = Math.atan2(zy,zx);
          const rp = Math.pow(rr,p);
          const ap = aa*p;
          zx = rp*Math.cos(ap) + x0;
          zy = rp*Math.sin(ap) + y0;
          if (zx*zx + zy*zy > escape) break;
        }
        return i;
      }

      if (type==="newton3"){
        let zx=x0, zy=y0;
        for(; i<maxIter; i++){
          const z2x = zx*zx - zy*zy;
          const z2y = 2*zx*zy;
          const z3x = z2x*zx - z2y*zy;
          const z3y = z2x*zy + z2y*zx;
          const fx = z3x - 1, fy = z3y;
          const dfx = 3*z2x, dfy = 3*z2y;
          const denom = dfx*dfx + dfy*dfy + 1e-12;
          const qx = (fx*dfx + fy*dfy)/denom;
          const qy = (fy*dfx - fx*dfy)/denom;
          zx -= qx; zy -= qy;
          if (fx*fx + fy*fy < 1e-10) break;
        }
        return i;
      }

      if (type==="phoenix"){
        const pr = lerp(-0.6, 0.2, 0.5 + 0.5*Math.sin(t*1.6 + S.fxDelay*2));
        const pi = lerp(-0.2, 0.6, 0.5 + 0.5*Math.cos(t*1.3 + S.fxChorus*2));
        let zx=x0, zy=y0, px=0, py=0;
        for(; i<maxIter; i++){
          const zx2 = zx*zx - zy*zy + ca + (pr*px - pi*py);
          const zy2 = 2*zx*zy + cb + (pr*py + pi*px);
          px=zx; py=zy;
          zx=zx2; zy=zy2;
          if (zx*zx + zy*zy > escape) break;
        }
        return i;
      }

      if (type==="celtic"){
        let zx=0, zy=0;
        for(; i<maxIter; i++){
          const xx = zx*zx - zy*zy;
          const yy = 2*zx*zy;
          zx = Math.abs(xx) + x0;
          zy = yy + y0;
          if (zx*zx + zy*zy > escape) break;
        }
        return i;
      }

      // spider
      {
        let zx=0, zy=0, cx=x0, cy=y0;
        for(; i<maxIter; i++){
          const zx2 = zx*zx - zy*zy + cx;
          const zy2 = 2*zx*zy + cy;
          zx=zx2; zy=zy2;
          cx = (cx + zx)*0.5;
          cy = (cy + zy)*0.5;
          if (zx*zx + zy*zy > escape) break;
        }
        return i;
      }
    }

    const hueBase = (t*0.06 + (S.keyRoot%12)/12) % 1;
    const sat = clamp(0.55 + 0.35*dens + 0.20*S.fxChorus, 0, 1);
    const grainAmt = 0.08 * S.lofi;

    let idx=0;
    for(let y=0;y<H;y++){
      const ny=(y/H - 0.5)*2;
      for(let x=0;x<W;x++){
        const nx=(x/W - 0.5)*2;
        const rx=(nx*cosr - ny*sinr)/zoom + lerp(-0.1, 0.1, drift);
        const ry=(nx*sinr + ny*cosr)/zoom + lerp(-0.05,0.05, bright);
        const it = iterate(rx, ry);
        const norm = it/maxIter;

        const hue = (hueBase + norm*0.95 + 0.12*Math.sin(t*1.3 + rx*3 + ry*2)) % 1;
        const val = clamp(0.08 + 0.92*Math.pow(1-norm, 0.52), 0, 1);
        const [rr,gg,bb] = hsv2rgb(hue, sat, val);
        const gr = (Math.random()-0.5)*grainAmt;

        data[idx++] = clamp((rr+gr)*255, 0, 255);
        data[idx++] = clamp((gg+gr)*255, 0, 255);
        data[idx++] = clamp((bb+gr)*255, 0, 255);
        data[idx++] = 255;
      }
    }

    fctx.putImageData(img,0,0);

    // scale to display (fast)
    dctx.imageSmoothingEnabled = false;
    dctx.clearRect(0,0,fractalDisplay.width,fractalDisplay.height);
    dctx.drawImage(off, 0,0, fractalDisplay.width, fractalDisplay.height);

    requestAnimationFrame(renderFractal);
  }

  // ---------- Overlay “bouncing trippy words” ----------
  const TRIP_WORDS = [
    "lull","drift","murmur","hush","nebula","glimmer","velvet","moss","drowse","zen","halo","softwave","loam","saffron","lucid",
    "bloom","float","ember","sway","breathe","aura","sublime","pulse","vapor","dreammilk","moonfoam","calmstatic","fizz","mellow",
    "tideglass","slowlight","cotton","satin","honeyhaze","tranquil","silkstorm","opal","dawnspill","afterglow","whisper","mosslight",
    "glowrift","nighttea","fable","mist","plume","dusk","ease","gentle","serene","snooze","starlace","quiet","stillness","drizzle",
    "coast","cloudroom","aurora","mirage","simmer","bokeh","harmony","glide","ether","gloss","tender","ambient","loop","spectrum",
    "violet","azure","indigo","pearl","basil","sage","lotus","koi","lagoon","cove","candle","incense","breeze","hammock","softcore",
    "hypno","shimmering","purring","sandalwood","rainroom","slowmo","sugarfog","mood","murmuration","cosmic","lush","pillow","nap",
    "crescent","orbit","soothe","sigh","euphoria","pocket","gentlecore","bloomwave","milkglass","garden","tapestry","driftwood","haze",
    "swaying","sleeptone","oceanlight","mellowtech","chill","cocoon","nimbus","gossamer","aether","glow","vibe","warmth","calmcraft",
    "spiral","frond","fern","ripple","thrum","murmurfield","honey","velour","bloomdust","stardust","daydream","moonbeam","softspark",
    "slowbrew","quietude","seraph","satinwave","lofi","muse","glitchbutter","dreamstatic","pollen","citrine","amethyst","jade","emberwave",
    "cloudkiss","sleepy","lowtide","milkmoon","auraglow","mossgarden","gentleloop","plush","feather","tint","tone","resonance","syrup",
    "purr","floaty","bluehour","duskmilk","nightbloom","calmwave","softglow","shylight","hushroom","mellowmist","mistwood","opaline",
    "glowmelt","silverslow","breath","easel","waxlight","hazeberry","sunkiss","starhush","sighwave","moonmoss","tealeaf","lazuli",
    "softer","slowly","dreamy","peace","easecraft","zenmist","ambientry","velvetine","satinmurmur","nebular","pillowtalk","lullaby",
    "glowfield","calmforge","driftcraft","sleepgarden","hushcraft","serenity","tranquility","chillcraft","dreamcraft","auracalm",
    "stillwater","softwater","nightwater","honeytone","mellowtone","blueglow","greenglade","violetfog","opalhaze","nebulafoam",
    "mindfloat","slowdrip","milkdrip","quietglow","softorbit","gentleorbit","lucidloop","warmloop","dreamloop","swayloop",
    "candlehaze","incensewave","breathglass","cloudglass","toneglass","sleepglass","glowglass","hushglass","moonlace","starlace",
    "duskveil","nightveil","calmveil","softveil","halofoam","auraveil","bloomveil","mossveil","quietveil","velvetveil",
    "soothewave","driftwave","hushwave","mellowwave","nebwave","glowwave","dreamwave","chillwave","zenwave","softwave",
    "rippled","shimmer","glimmering","hazy","mellowing","swaying","floating","breathing","drifting","whispering",
    "sandal","cedar","cypress","lavender","vanilla","tea","chai","matcha","mint","rose",
    "lagoonlight","covelight","harborhush","shoreglow","tidehush","nightshore","foam","spray","seafoam","saltlight",
    "astral","stellar","lunar","solar","orbiting","nebularis","cosmica","auraline","opalescent","iridescent",
    "gentlegeist","chillspiral","slowspiral","softspiral","dreamspiral","hushspiral","bloomspiral","mossspiral","glowspiral","zenspiral"
  ];
  // pad to ~300 deterministically
  while (TRIP_WORDS.length < 300) TRIP_WORDS.push(TRIP_WORDS[TRIP_WORDS.length % 120] + "-" + (TRIP_WORDS.length));

  const words = [];
  function resetWords(){
    words.length = 0;
    reseedFromText((S.seedText||"NOS-GOLD") + "|words");
    const n = clamp(S.wordCount|0, 8, 48);
    for (let i=0;i<n;i++){
      const w = TRIP_WORDS[ri(TRIP_WORDS.length)];
      words.push({
        text: w,
        x: r(), y: r(),
        vx: (r()*2-1)*0.0025,
        vy: (r()*2-1)*0.0025,
        hue: r(),
        size: 10 + r()*16,
        phase: r()*Math.PI*2
      });
    }
  }
  resetWords();

  let lastWordsFrame = 0;
  function drawOverlay(ts){
    const dt = ts - lastWordsFrame;
    if (dt < 33){ requestAnimationFrame(drawOverlay); return; } // ~30fps
    lastWordsFrame = ts;

    const W = overlayCanvas.width, H = overlayCanvas.height;
    octx.clearRect(0,0,W,H);

    const t = ts * 0.001;
    const warp = S.wordWarp;
    const spd = S.wordSpeed;

    // tie colors to music
    const hueBase = ((S.keyRoot%12)/12 + (t*0.03)) % 1;
    const sat = clamp(0.55 + 0.35*S.density + 0.20*S.fxChorus, 0, 1);

    // update & draw
    for (let i=0;i<words.length;i++){
      const w = words[i];

      // bounce in normalized space
      w.x += w.vx * lerp(0.35, 2.2, spd);
      w.y += w.vy * lerp(0.35, 2.2, spd);

      if (w.x < 0){ w.x=0; w.vx = Math.abs(w.vx); }
      if (w.x > 1){ w.x=1; w.vx = -Math.abs(w.vx); }
      if (w.y < 0){ w.y=0; w.vy = Math.abs(w.vy); }
      if (w.y > 1){ w.y=1; w.vy = -Math.abs(w.vy); }

      // random retint & word swap sometimes (seeded-ish + evolving)
      if (Math.random() < 0.02 + 0.06*S.mutate){
        w.text = TRIP_WORDS[(Math.random()*TRIP_WORDS.length)|0];
        w.hue = (w.hue + 0.15 + 0.35*Math.random()) % 1;
      }

      const px = w.x * W;
      const py = w.y * H;

      // warp: draw each word as characters with offsets
      const hue = (hueBase + w.hue + 0.15*Math.sin(t*0.8 + w.phase)) % 1;
      const [rr,gg,bb] = hsv2rgb(hue, sat, 1.0);
      octx.fillStyle = `rgba(${(rr*255)|0},${(gg*255)|0},${(bb*255)|0},0.92)`;
      octx.font = `${Math.floor(w.size)}px Papyrus, Comic Sans MS, cursive`;
      octx.textBaseline = "middle";

      const wob = warp * (2.0 + 8.0*S.lofi + 4.0*S.fxChorus);
      const text = w.text;
      let x = px, y = py;

      // subtle color warp trail
      if (warp > 0.02){
        octx.save();
        octx.globalAlpha = 0.18;
        octx.fillStyle = `rgba(${(bb*255)|0},${(rr*255)|0},${(gg*255)|0},0.35)`;
        octx.fillText(text, x + Math.sin(t*2 + w.phase)*wob*0.8, y + Math.cos(t*2.2 + w.phase)*wob*0.8);
        octx.restore();
      }

      if (warp < 0.05){
        octx.fillText(text, x, y);
      } else {
        // per-character warp (cheap)
        let cx = x;
        for (let c=0;c<text.length;c++){
          const ch = text[c];
          const offx = Math.sin(t*2.2 + w.phase + c*0.55) * wob;
          const offy = Math.cos(t*2.0 + w.phase + c*0.48) * wob;
          octx.fillText(ch, cx + offx, y + offy);
          cx += octx.measureText(ch).width;
        }
      }
    }

    requestAnimationFrame(drawOverlay);
  }

  // adjust word count changes live
  UI.wordCount.addEventListener("input", ()=>resetWords(), {passive:true});

  // ---------- start/stop ----------
  document.getElementById("regen").onclick = () => {
    regenPhraseAndBeats();
    resetWords();
  };

  document.getElementById("start").onclick = async () => {
    ensureAudio();
    await ac.resume();
    if (running) return;

    // (re)seed + generate base phrase/beat from text
    S.seedText = seedEl.value.slice(0,100);
    regenPhraseAndBeats();
    resetWords();

    running = true;
    document.getElementById("start").disabled = true;
    document.getElementById("stop").disabled = false;

    S.bar=0; S.step=0;
    S.nextTime = ac.currentTime + 0.05;
    S.drift={v:0,dv:0}; S.bright={v:0,dv:0}; S.wow={v:0,dv:0}; S.flutter={v:0,dv:0}; S.swingW={v:0,dv:0};

    masterG.gain.setValueAtTime(S.master, ac.currentTime);

    timer = setInterval(scheduleAhead, 25);
  };

  document.getElementById("stop").onclick = () => {
    if (!running) return;
    running=false;
    clearInterval(timer); timer=null;

    const t=ac.currentTime;
    masterG.gain.setTargetAtTime(0.0001, t, 0.12);
    setTimeout(()=>{ try{ ac.suspend(); }catch{} masterG.gain.setValueAtTime(S.master, ac.currentTime); }, 380);

    document.getElementById("start").disabled = false;
    document.getElementById("stop").disabled = true;
  };

  // ---------- kick off visuals ----------
  requestAnimationFrame(renderFractal);
  requestAnimationFrame(drawOverlay);

})();
</script>
</body>
</html>
